<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Timeline + Selected Table + Map</title>

    <!-- vis-timeline -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vis-timeline@8.5.0/styles/vis-timeline-graph2d.min.css">
    <script src="https://cdn.jsdelivr.net/npm/vis-timeline@8.5.0/standalone/umd/vis-timeline-graph2d.min.js"></script>

    <!-- PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root { color-scheme: light dark; }
        body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
        header { padding: 14px 16px; border-bottom: 1px solid rgba(127,127,127,.25); }
        header h1 { margin: 0; font-size: 18px; }
        header p { margin: 6px 0 0; opacity: .8; }

        .app { display: grid; grid-template-columns: 340px 1fr; gap: 12px; padding: 12px; }
        .panel { border: 1px solid rgba(127,127,127,.25); border-radius: 10px; padding: 12px; height: fit-content; position: sticky; top: 12px; }
        .panel h2 { font-size: 14px; margin: 0 0 10px; opacity: .9; }

        .row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }
        label { font-size: 12px; opacity: .85; }
        input[type="date"], select, button {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(127,127,127,.35);
            background: transparent;
            color: inherit;
        }
        button { cursor: pointer; }
        .btnrow { display: flex; gap: 8px; flex-wrap: wrap; }

        .dropzone {
            border: 2px dashed rgba(127,127,127,.45);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
            margin-bottom: 12px;
            user-select: none;
        }
        .dropzone strong { display: block; margin-bottom: 6px; }
        .dropzone small { opacity: .8; }
        .dropzone.dragover { border-color: rgba(80,160,255,.9); }

        .status {
            border: 1px solid rgba(127,127,127,.25);
            border-radius: 10px;
            padding: 10px;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-wrap;
            max-height: 220px;
            overflow: auto;
            background: rgba(127,127,127,.06);
        }

        .main { display: grid; grid-template-rows: 420px auto 360px; gap: 12px; min-width: 0; }
        .box { border: 1px solid rgba(127,127,127,.25); border-radius: 10px; overflow: hidden; background: transparent; min-width: 0; }
        #timeline { height: 420px; }
        .boxhead { padding: 10px 12px; border-bottom: 1px solid rgba(127,127,127,.25); display: flex; justify-content: space-between; gap: 10px; align-items: baseline; flex-wrap: wrap; }
        .boxhead h3 { margin: 0; font-size: 14px; }
        .boxhead .meta { font-size: 12px; opacity: .75; }

        .tablewrap { overflow: auto; max-height: 320px; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th, td { padding: 8px 10px; border-bottom: 1px solid rgba(127,127,127,.2); vertical-align: top; }
        th { position: sticky; top: 0; background: rgba(127,127,127,.08); text-align: left; }
        tr:hover { background: rgba(127,127,127,.08); }
        .muted { opacity: .75; }

        #map { height: 360px; }
        .pill { display: inline-block; padding: 2px 8px; border: 1px solid rgba(127,127,127,.35); border-radius: 999px; margin-right: 6px; margin-bottom: 4px; font-size: 12px; opacity: .9; white-space: nowrap; }

        /* Floating debug overlay (hidden unless enabled) */
        #dbgOverlay {
            position: fixed;
            bottom: 12px;
            right: 12px;
            z-index: 999999;
            width: min(520px, 92vw);
            max-height: 46vh;
            overflow: auto;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(180,180,180,.55);
            background: rgba(0,0,0,.72);
            color: #fff;
            font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            white-space: pre-wrap;
            box-shadow: 0 10px 30px rgba(0,0,0,.3);
            display: none;
        }
        #dbgOverlay .hdr {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            position: sticky;
            top: 0;
            background: rgba(0,0,0,.72);
            padding-bottom: 6px;
        }
        #dbgOverlay .hdr strong { font-size: 12px; }
        #dbgOverlay .hdr button {
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.25);
            background: rgba(255,255,255,.06);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
        }
        #dbgOverlay .hdr button:hover { background: rgba(255,255,255,.12); }
        #dbgOverlay .line { opacity: .95; }
        #dbgOverlay .warn { color: #ffd37a; }
        #dbgOverlay .err { color: #ff9aa2; }
        #dbgOverlay .ok { color: #a7ffb0; }

        @media (max-width: 980px) {
            .app { grid-template-columns: 1fr; }
            .panel { position: static; }
            .main { grid-template-rows: 420px auto 320px; }
        }
    </style>
</head>

<body>
<header>
    <h1>My Timelines</h1>
    <p>Upload a CSV → timeline. Select items → table + map pins. (Geocoding: location ⇄ lat/lon.)</p>
</header>

<div class="app">
    <aside class="panel">
        <div id="dropzone" class="dropzone" tabindex="0">
            <strong>Click to upload CSV</strong>
            <small>(drag/drop also works)</small>
            <input id="fileInput" type="file" accept=".csv,text/csv" style="display:none" />
        </div>

        <h2>Status</h2>
        <div id="status" class="status">Waiting for a CSV…</div>

        <h2 style="margin-top:12px">Debug</h2>
        <div class="row">
            <label>Debug mode</label>
            <select id="debugMode">
                <option value="off" selected>Off</option>
                <option value="overlayOnly">Overlay only</option>
                <option value="on">On (overlay + console)</option>
            </select>
        </div>
        <div class="btnrow">
            <button id="clearDbgBtn" type="button">Clear debug log</button>
            <button id="copyDbgBtn" type="button">Copy debug log</button>
        </div>

        <h2 style="margin-top:12px">Filters</h2>

        <div class="row">
            <label>Date range</label>
            <input id="fromDate" type="date" />
            <input id="toDate" type="date" />
        </div>

        <div class="row">
            <label>Filter by tag</label>
            <select id="tagFilter"><option value="">All tags</option></select>
        </div>

        <div class="row">
            <label>Filter by location</label>
            <select id="locFilter"><option value="">All locations</option></select>
        </div>

        <div class="btnrow">
            <button id="applyBtn" type="button">Apply</button>
            <button id="resetBtn" type="button">Reset</button>
        </div>

        <p class="muted" style="margin-top:12px;font-size:12px">
            Tip: Ctrl/Cmd+click selects multiple. Shift+click attempts range selection (timeline dependent).
        </p>

        <p class="muted" style="margin-top:12px;font-size:12px">
            Geocoding uses the public OpenStreetMap Nominatim service. If you plan heavy classroom usage, consider hosting your
            own geocoder or adding an API key–based provider.
        </p>
    </aside>

    <main class="main">
        <section class="box">
            <div class="boxhead">
                <h3>Timeline</h3>
                <div class="meta"><span id="countLabel">0</span> items loaded</div>
            </div>
            <div id="timeline"></div>
        </section>

        <section class="box">
            <div class="boxhead">
                <h3>Selected items</h3>
                <div class="meta"><span id="selectedCount">0</span> selected</div>
            </div>
            <div class="tablewrap">
                <table>
                    <thead>
                    <tr>
                        <th style="min-width:140px">When</th>
                        <th style="min-width:180px">Title</th>
                        <th style="min-width:220px">Details</th>
                        <th style="min-width:160px">Tags</th>
                        <th style="min-width:200px">Location</th>
                        <th style="min-width:160px">Coordinates</th>
                    </tr>
                    </thead>
                    <tbody id="selectedTbody">
                    <tr><td colspan="6" class="muted">Select timeline items to populate this table.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="box">
            <div class="boxhead">
                <h3>Map</h3>
                <div class="meta">Plots selected items (lat/lon inferred from location if needed)</div>
            </div>
            <div id="map"></div>
        </section>
    </main>
</div>

<!-- Debug overlay -->
<div id="dbgOverlay" aria-live="polite">
    <div class="hdr">
        <strong>DBG overlay</strong>
        <div style="display:flex;gap:8px;align-items:center">
            <button id="toggleDbgBtn" type="button">Hide</button>
        </div>
    </div>
    <div id="dbgLog"></div>
</div>

<script>
    /* =========================================================
       DEBUG HELPERS (default OFF)
       ========================================================= */
    (function () {
        const statusEl = document.getElementById("status");
        const dbgOverlay = document.getElementById("dbgOverlay");
        const dbgLog = document.getElementById("dbgLog");
        const debugModeSel = document.getElementById("debugMode");
        const toggleDbgBtn = document.getElementById("toggleDbgBtn");
        const clearDbgBtn = document.getElementById("clearDbgBtn");
        const copyDbgBtn = document.getElementById("copyDbgBtn");

        const DBG = {
            enabled: false,
            overlayEnabled: false,
            consoleEnabled: false,
            lines: [],
            maxLines: 400
        };

        function ts() {
            const d = new Date();
            return d.toISOString().replace("T", " ").replace("Z", "");
        }
        function escapeHtml(s) {
            return String(s ?? "")
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");
        }

        function renderOverlay() {
            if (!DBG.overlayEnabled) return;
            dbgLog.innerHTML = DBG.lines.map(l => {
                const cls = l.level === "err" ? "err" : (l.level === "warn" ? "warn" : (l.level === "ok" ? "ok" : "line"));
                return `<div class="${cls}">${escapeHtml(l.text)}</div>`;
            }).join("");
            dbgOverlay.scrollTop = dbgOverlay.scrollHeight;
        }

        function pushLine(level, msg) {
            const text = `[${ts()}] ${msg}`;
            DBG.lines.push({ level, text });
            if (DBG.lines.length > DBG.maxLines) DBG.lines.splice(0, DBG.lines.length - DBG.maxLines);
            if (DBG.consoleEnabled) {
                const tag = "[APP]";
                if (level === "err") console.error(tag, msg);
                else if (level === "warn") console.warn(tag, msg);
                else console.log(tag, msg);
            }
            renderOverlay();
        }

        function setMode(mode) {
            if (mode === "off") {
                DBG.enabled = false;
                DBG.overlayEnabled = false;
                DBG.consoleEnabled = false;
                dbgOverlay.style.display = "none";
                pushLine("line", "Debug mode OFF.");
                return;
            }
            if (mode === "overlayOnly") {
                DBG.enabled = true;
                DBG.overlayEnabled = true;
                DBG.consoleEnabled = false;
                dbgOverlay.style.display = "";
                pushLine("ok", "Debug mode OVERLAY ONLY.");
                return;
            }
            DBG.enabled = true;
            DBG.overlayEnabled = true;
            DBG.consoleEnabled = true;
            dbgOverlay.style.display = "";
            pushLine("ok", "Debug mode ON.");
        }

        function setStatus(msg) {
            statusEl.textContent = msg;
            pushLine("line", `STATUS: ${msg}`);
        }
        function appendStatus(msg) {
            statusEl.textContent += "\n" + msg;
            pushLine("line", msg);
        }

        window.__DBG = {
            setMode,
            setStatus,
            appendStatus,
            log: (m) => pushLine("line", m),
            ok: (m) => pushLine("ok", m),
            warn: (m) => pushLine("warn", m),
            err: (m) => pushLine("err", m),
            clear: () => { DBG.lines = []; renderOverlay(); },
            dumpText: () => DBG.lines.map(l => l.text).join("\n"),
            enabled: () => DBG.enabled
        };

        // Error traps (only visible if debug enabled)
        window.addEventListener("error", (e) => {
            if (!DBG.enabled) return;
            window.__DBG.err(`WINDOW ERROR: ${e.message || e.type} @ ${e.filename || "?"}:${e.lineno || "?"}:${e.colno || "?"}`);
        });
        window.addEventListener("unhandledrejection", (e) => {
            if (!DBG.enabled) return;
            const reason = e.reason?.message || String(e.reason);
            window.__DBG.err(`UNHANDLED PROMISE: ${reason}`);
        });

        debugModeSel.addEventListener("change", () => setMode(debugModeSel.value));
        toggleDbgBtn.addEventListener("click", () => {
            const isHidden = dbgLog.style.display === "none";
            dbgLog.style.display = isHidden ? "" : "none";
            toggleDbgBtn.textContent = isHidden ? "Hide" : "Show";
        });
        clearDbgBtn.addEventListener("click", () => window.__DBG.clear());
        copyDbgBtn.addEventListener("click", async () => {
            try {
                await navigator.clipboard.writeText(window.__DBG.dumpText());
                setStatus("Copied debug log to clipboard.");
            } catch {
                setStatus("Clipboard copy failed (permissions).");
            }
        });

        // Default is OFF (per your request)
        setMode("off");
    })();

    /* =========================================================
       GEOCODING (location ⇄ lat/lon) with caching + throttling
       ========================================================= */
    const Geo = (() => {
        const NOMINATIM_BASE = "https://nominatim.openstreetmap.org";
        const LS_FWD = "geo_fwd_cache_v1";
        const LS_REV = "geo_rev_cache_v1";

        /** Rate limiting: run one request at a time, with delay. */
        let chain = Promise.resolve();
        const MIN_DELAY_MS = 1100;

        function loadCache(key) {
            try { return JSON.parse(localStorage.getItem(key) || "{}"); }
            catch { return {}; }
        }
        function saveCache(key, obj) {
            try { localStorage.setItem(key, JSON.stringify(obj)); } catch {}
        }

        const fwdCache = loadCache(LS_FWD); // location string -> {lat, lon, display}
        const revCache = loadCache(LS_REV); // "lat,lon" -> display

        function normalizeLoc(s) {
            return String(s || "").trim();
        }
        function revKey(lat, lon) {
            // reduce cardinality a bit, but keep enough precision
            const a = Number(lat).toFixed(5);
            const b = Number(lon).toFixed(5);
            return `${a},${b}`;
        }

        function enqueue(fn) {
            chain = chain.then(async () => {
                const start = Date.now();
                const out = await fn();
                const elapsed = Date.now() - start;
                const wait = Math.max(0, MIN_DELAY_MS - elapsed);
                if (wait) await new Promise(r => setTimeout(r, wait));
                return out;
            }).catch(err => {
                // keep chain alive
                if (window.__DBG?.enabled?.()) window.__DBG.warn("Geocode queue error: " + (err?.message || String(err)));
                return null;
            });
            return chain;
        }

        async function forward(locationStr) {
            const q = normalizeLoc(locationStr);
            if (!q) return null;

            if (fwdCache[q]) return fwdCache[q];

            return enqueue(async () => {
                // Use format=jsonv2 for consistent fields
                const url = `${NOMINATIM_BASE}/search?format=jsonv2&limit=1&q=${encodeURIComponent(q)}`;
                if (window.__DBG?.enabled?.()) window.__DBG.log("Geocode forward: " + q);

                const res = await fetch(url, {
                    method: "GET",
                    headers: {
                        // Browsers set UA; we keep headers minimal.
                        "Accept": "application/json"
                    }
                });
                if (!res.ok) return null;

                const data = await res.json();
                if (!Array.isArray(data) || data.length === 0) return null;

                const hit = data[0];
                const lat = Number(hit.lat);
                const lon = Number(hit.lon);
                const display = String(hit.display_name || q);

                if (!isFinite(lat) || !isFinite(lon)) return null;

                const val = { lat, lon, display };
                fwdCache[q] = val;
                saveCache(LS_FWD, fwdCache);
                return val;
            });
        }

        async function reverse(lat, lon) {
            if (!isFinite(lat) || !isFinite(lon)) return null;

            const key = revKey(lat, lon);
            if (revCache[key]) return revCache[key];

            return enqueue(async () => {
                const url = `${NOMINATIM_BASE}/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
                if (window.__DBG?.enabled?.()) window.__DBG.log("Geocode reverse: " + key);

                const res = await fetch(url, {
                    method: "GET",
                    headers: { "Accept": "application/json" }
                });
                if (!res.ok) return null;

                const data = await res.json();
                const display = String(data.display_name || "");
                if (!display) return null;

                revCache[key] = display;
                saveCache(LS_REV, revCache);
                return display;
            });
        }

        return { forward, reverse };
    })();

    /* =========================================================
       APP
       ========================================================= */
    (function () {
        // ---------- Utilities ----------
        function normKey(s) { return String(s || "").trim().toLowerCase().replace(/\s+/g, "_"); }
        function escapeHtml(s) {
            return String(s ?? "")
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");
        }
        function parseTags(raw) {
            if (!raw) return [];
            return String(raw).split(/[,;|]/g).map(t => t.trim()).filter(Boolean);
        }
        function safeDate(val) {
            if (val === null || val === undefined) return null;
            const s = String(val).trim();
            if (!s) return null;

            let d = new Date(s);
            if (!isNaN(d.getTime())) return d;

            const m1 = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
            if (m1) {
                const [_, Y, M, D, hh="0", mm="0", ss="0"] = m1;
                d = new Date(Number(Y), Number(M)-1, Number(D), Number(hh), Number(mm), Number(ss));
                if (!isNaN(d.getTime())) return d;
            }

            const m2 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
            if (m2) {
                const [_, M, D, Y, hh="0", mm="0"] = m2;
                d = new Date(Number(Y), Number(M)-1, Number(D), Number(hh), Number(mm), 0);
                if (!isNaN(d.getTime())) return d;
            }

            return null;
        }
        function fmtWhen(item) {
            const s = item.start ? new Date(item.start) : null;
            const e = item.end ? new Date(item.end) : null;
            const fmt = (x) => x.toISOString().slice(0,10);
            if (s && e) return `${fmt(s)} → ${fmt(e)}`;
            if (s) return fmt(s);
            return "";
        }
        function findCol(headersNorm, candidates) {
            for (const c of candidates) {
                const want = normKey(c);
                const idx = headersNorm.indexOf(want);
                if (idx !== -1) return idx;
            }
            return -1;
        }
        function guessDateCol(fields, rows, sampleN = 50) {
            if (!fields.length) return -1;
            const N = Math.min(sampleN, rows.length);
            const scores = fields.map(() => 0);
            for (let i = 0; i < N; i++) {
                const r = rows[i];
                if (!r) continue;
                for (let c = 0; c < fields.length; c++) {
                    const v = r[fields[c]];
                    if (safeDate(v)) scores[c] += 1;
                }
            }
            let best = -1, bestScore = 0;
            for (let c = 0; c < scores.length; c++) {
                if (scores[c] > bestScore) { bestScore = scores[c]; best = c; }
            }
            return bestScore >= Math.max(3, Math.floor(N * 0.2)) ? best : -1;
        }

        // ---------- State ----------
        let allItems = [];
        let itemsById = new Map();
        let timeline = null;
        let visData = null;

        let map = null;
        let markerLayer = null;

        let currentSelectedIds = [];

        // ---------- DOM ----------
        const dropzone = document.getElementById("dropzone");
        const fileInput = document.getElementById("fileInput");

        const fromDate = document.getElementById("fromDate");
        const toDate = document.getElementById("toDate");
        const tagFilter = document.getElementById("tagFilter");
        const locFilter = document.getElementById("locFilter");

        const applyBtn = document.getElementById("applyBtn");
        const resetBtn = document.getElementById("resetBtn");

        const countLabel = document.getElementById("countLabel");
        const selectedCount = document.getElementById("selectedCount");
        const selectedTbody = document.getElementById("selectedTbody");

        // ---------- Geo rules you requested ----------
        // 1) location + no lat/lon => forward geocode to get lat/lon
        // 2) lat/lon + no location => reverse geocode to get location (for display); map uses lat/lon immediately
        // 3) both present => lat/lon overrides (we still keep provided location for display; can also reverse-fill if you prefer)
        // Also: if lat/lon exist but location empty, we try to fill location.

        // We track in-flight geocode per item to avoid duplicate requests.
        const inFlight = new Map(); // item.id -> Promise

        function hasCoords(it) {
            return isFinite(it.lat) && isFinite(it.lon);
        }

        async function ensureGeo(it) {
            // If already in-flight, await it.
            if (inFlight.has(it.id)) return inFlight.get(it.id);

            const p = (async () => {
                const loc = String(it.location || "").trim();

                // If coordinates exist:
                if (hasCoords(it)) {
                    // If no location, reverse geocode to fill display location (optional but requested)
                    if (!loc) {
                        const display = await Geo.reverse(it.lat, it.lon);
                        if (display) {
                            it.location = display;
                            if (window.__DBG?.enabled?.()) window.__DBG.ok(`Reverse geocoded ${it.lat},${it.lon} -> ${display}`);
                        }
                    }
                    return it;
                }

                // No coords, but location exists: forward geocode
                if (loc) {
                    const hit = await Geo.forward(loc);
                    if (hit && isFinite(hit.lat) && isFinite(hit.lon)) {
                        it.lat = hit.lat;
                        it.lon = hit.lon;
                        // keep original location text; but if you want standardized display_name, uncomment:
                        // it.location = hit.display || it.location;
                        if (window.__DBG?.enabled?.()) window.__DBG.ok(`Forward geocoded "${loc}" -> ${it.lat},${it.lon}`);
                    } else {
                        if (window.__DBG?.enabled?.()) window.__DBG.warn(`Forward geocode failed for "${loc}"`);
                    }
                }

                return it;
            })().finally(() => {
                inFlight.delete(it.id);
            });

            inFlight.set(it.id, p);
            return p;
        }

        // ---------- Timeline ----------
        function initTimeline() {
            const container = document.getElementById("timeline");
            visData = new vis.DataSet([]);
            timeline = new vis.Timeline(container, visData, {
                stack: true,
                multiselect: true,
                selectable: true,
                zoomKey: "ctrlKey"
            });

            timeline.on("select", (props) => {
                currentSelectedIds = props.items || [];
                updateSelectedUI(currentSelectedIds);
            });
        }

        // ---------- Map ----------
        function initMap() {
            map = L.map("map", { zoomControl: true });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: "&copy; OpenStreetMap contributors"
            }).addTo(map);

            markerLayer = L.layerGroup().addTo(map);
            map.setView([20, 0], 2);
        }

        // ---------- Selection -> Table + Map ----------
        function updateSelectedUI(selectedIds) {
            selectedCount.textContent = String(selectedIds.length);

            selectedTbody.innerHTML = "";
            if (selectedIds.length === 0) {
                selectedTbody.innerHTML = `<tr><td colspan="6" class="muted">Select timeline items to populate this table.</td></tr>`;
                markerLayer.clearLayers();
                return;
            }

            // Render table first (even if geocode pending)
            for (const id of selectedIds) {
                const it = itemsById.get(id);
                if (!it) continue;

                const tagsHtml = (it.tags || []).length
                    ? it.tags.map(t => `<span class="pill">${escapeHtml(t)}</span>`).join("")
                    : `<span class="muted">—</span>`;

                const loc = it.location ? escapeHtml(it.location) : `<span class="muted">—</span>`;

                let coordsCell = `<span class="muted">—</span>`;
                if (hasCoords(it)) {
                    coordsCell = `${Number(it.lat).toFixed(5)}, ${Number(it.lon).toFixed(5)}`;
                } else if (String(it.location || "").trim()) {
                    coordsCell = `<span class="muted">geocoding…</span>`;
                }

                const details = it.details ? escapeHtml(it.details) : `<span class="muted">—</span>`;

                const tr = document.createElement("tr");
                tr.setAttribute("data-item-id", it.id);
                tr.innerHTML = `
        <td>${escapeHtml(fmtWhen(it))}</td>
        <td>${escapeHtml(it.title || "")}</td>
        <td>${details}</td>
        <td>${tagsHtml}</td>
        <td>${loc}</td>
        <td>${coordsCell}</td>
      `;
                selectedTbody.appendChild(tr);
            }

            // Map update: add markers for what we already have, then geocode missing and refresh
            refreshMapMarkers(selectedIds);

            // Kick off geocoding for selected items that need it
            for (const id of selectedIds) {
                const it = itemsById.get(id);
                if (!it) continue;

                const needsFwd = !hasCoords(it) && String(it.location || "").trim();
                const needsRev = hasCoords(it) && !String(it.location || "").trim();

                if (needsFwd || needsRev) {
                    ensureGeo(it).then(() => {
                        // After geo resolves, only refresh if still selected
                        if (currentSelectedIds.includes(id)) {
                            // Re-render table row coords/location quickly
                            patchSelectedRow(id);
                            // And update markers
                            refreshMapMarkers(currentSelectedIds);
                        }
                    });
                }
            }
        }

        function patchSelectedRow(id) {
            const it = itemsById.get(id);
            const tr = selectedTbody.querySelector(`tr[data-item-id="${CSS.escape(id)}"]`);
            if (!it || !tr) return;

            // Location cell is 5th (index 4), coords cell 6th (index 5)
            const tds = tr.querySelectorAll("td");
            if (tds.length >= 6) {
                tds[4].innerHTML = it.location ? escapeHtml(it.location) : `<span class="muted">—</span>`;
                if (hasCoords(it)) {
                    tds[5].textContent = `${Number(it.lat).toFixed(5)}, ${Number(it.lon).toFixed(5)}`;
                } else if (String(it.location || "").trim()) {
                    tds[5].innerHTML = `<span class="muted">geocoding…</span>`;
                } else {
                    tds[5].innerHTML = `<span class="muted">—</span>`;
                }
            }
        }

        function refreshMapMarkers(selectedIds) {
            markerLayer.clearLayers();
            const bounds = [];

            for (const id of selectedIds) {
                const it = itemsById.get(id);
                if (!it) continue;

                // If we don't have coords yet, skip for now; geocode will call back and refresh.
                if (!hasCoords(it)) continue;

                const title = escapeHtml(it.title || "Item");
                const loc = escapeHtml(it.location || "");
                const when = escapeHtml(fmtWhen(it));

                const m = L.marker([it.lat, it.lon])
                    .bindPopup(`<strong>${title}</strong><br>${loc}<br><span class="muted">${when}</span>`);
                markerLayer.addLayer(m);
                bounds.push([it.lat, it.lon]);
            }

            if (bounds.length === 1) map.setView(bounds[0], 10);
            if (bounds.length > 1) map.fitBounds(bounds, { padding: [20, 20] });
            if (bounds.length === 0) {
                // keep current view
            }
        }

        // ---------- Filtering ----------
        function rebuildFilterOptions(items) {
            const tags = new Set();
            const locs = new Set();
            for (const it of items) {
                (it.tags || []).forEach(t => tags.add(t));
                if (it.location) locs.add(it.location);
            }

            const curTag = tagFilter.value;
            const curLoc = locFilter.value;

            tagFilter.innerHTML = `<option value="">All tags</option>` +
                Array.from(tags).sort((a,b)=>a.localeCompare(b)).map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join("");

            locFilter.innerHTML = `<option value="">All locations</option>` +
                Array.from(locs).sort((a,b)=>a.localeCompare(b)).map(l => `<option value="${escapeHtml(l)}">${escapeHtml(l)}</option>`).join("");

            tagFilter.value = Array.from(tags).includes(curTag) ? curTag : "";
            locFilter.value = Array.from(locs).includes(curLoc) ? curLoc : "";
        }

        function applyFilters() {
            const fd = fromDate.value ? safeDate(fromDate.value) : null;
            const td = toDate.value ? safeDate(toDate.value) : null;
            const tag = tagFilter.value || "";
            const loc = locFilter.value || "";

            const filtered = allItems.filter(it => {
                const s = it.start ? new Date(it.start) : null;
                const e = it.end ? new Date(it.end) : null;
                const anchor = s || e;
                if (fd && anchor && anchor < fd) return false;
                if (td && anchor && anchor > td) return false;
                if (tag && !(it.tags || []).includes(tag)) return false;
                if (loc && (it.location || "") !== loc) return false;
                return true;
            });

            visData.clear();
            visData.add(filtered.map(it => ({
                id: it.id,
                start: it.start,
                end: it.end || undefined,
                content: it.content,
                title: it.tooltip
            })));

            countLabel.textContent = String(filtered.length);

            currentSelectedIds = [];
            timeline.setSelection([]);
            updateSelectedUI([]);

            document.getElementById("status").textContent =
                `Applied filters. Showing ${filtered.length} / ${allItems.length} items.`;
        }

        function resetFilters() {
            fromDate.value = "";
            toDate.value = "";
            tagFilter.value = "";
            locFilter.value = "";

            visData.clear();
            visData.add(allItems.map(it => ({
                id: it.id,
                start: it.start,
                end: it.end || undefined,
                content: it.content,
                title: it.tooltip
            })));

            countLabel.textContent = String(allItems.length);

            currentSelectedIds = [];
            timeline.setSelection([]);
            updateSelectedUI([]);

            document.getElementById("status").textContent = `Reset filters. Showing all ${allItems.length} items.`;
        }

        // ---------- CSV -> items ----------
        function buildItemsFromParsed(fields, rows) {
            const headersNorm = fields.map(normKey);

            let idxStart = findCol(headersNorm, ["start", "date", "when", "begin", "timestamp", "time"]);
            const idxEnd = findCol(headersNorm, ["end", "finish", "stop", "until"]);
            const idxTitle = findCol(headersNorm, ["title", "name", "event", "summary"]);
            const idxDetails = findCol(headersNorm, ["details", "description", "content", "notes", "text", "body"]);
            const idxTags = findCol(headersNorm, ["tags", "tag", "labels", "label"]);
            const idxLoc = findCol(headersNorm, ["location", "place", "where", "city"]);
            const idxLat = findCol(headersNorm, ["lat", "latitude"]);
            const idxLon = findCol(headersNorm, ["lon", "lng", "longitude", "long"]);

            if (idxStart === -1) {
                idxStart = guessDateCol(fields, rows);
                if (window.__DBG?.enabled?.()) window.__DBG.warn(`Guessed start column: ${idxStart >= 0 ? fields[idxStart] : "NONE"}`);
            }

            if (idxStart === -1) {
                return { items: [], skipped: rows.length, err: "Could not find a date/start column." };
            }

            const now = Date.now();
            const items = [];
            let skipped = 0;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                if (!row || Object.keys(row).length === 0) { skipped++; continue; }

                const startVal = row[fields[idxStart]];
                const endVal = (idxEnd >= 0) ? row[fields[idxEnd]] : null;

                const start = safeDate(startVal);
                const end = safeDate(endVal);

                if (!start) { skipped++; continue; }

                const title = (idxTitle >= 0 ? String(row[fields[idxTitle]] || "").trim() : "") || "Item";
                const details = idxDetails >= 0 ? String(row[fields[idxDetails]] || "").trim() : "";
                const tags = idxTags >= 0 ? parseTags(row[fields[idxTags]]) : [];
                const location = idxLoc >= 0 ? String(row[fields[idxLoc]] || "").trim() : "";

                const lat = idxLat >= 0 ? Number(row[fields[idxLat]]) : NaN;
                const lon = idxLon >= 0 ? Number(row[fields[idxLon]]) : NaN;

                // Rule: if both location and lat/lon exist, lat/lon "wins" for mapping (we already use coords if present).
                // We keep location text as-is for display, unless empty and reverse geocode fills it later.

                const id = `${now}-${i}`;
                const content = `<div><strong>${escapeHtml(title)}</strong><div class="muted" style="font-size:12px">${escapeHtml(location || "")}</div></div>`;

                const tooltipParts = [];
                tooltipParts.push(title);
                tooltipParts.push(fmtWhen({ start, end }));
                if (location) tooltipParts.push(location);
                if (tags.length) tooltipParts.push(`Tags: ${tags.join(", ")}`);
                if (details) tooltipParts.push(details);

                items.push({
                    id,
                    start,
                    end,
                    title,
                    details,
                    tags,
                    location,
                    lat,
                    lon,
                    content,
                    tooltip: tooltipParts.filter(Boolean).join("\n")
                });
            }

            return { items, skipped, err: null };
        }

        function loadCsvFile(file) {
            const statusEl = document.getElementById("status");
            statusEl.textContent = `Reading: ${file.name} (${file.size} bytes)…`;

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                complete: (results) => {
                    const fields = (results.meta && results.meta.fields) ? results.meta.fields : [];
                    const rows = results.data || [];

                    if (!fields.length) {
                        statusEl.textContent = "ERROR: No headers detected. Ensure the first row is a header row.";
                        return;
                    }

                    const { items, skipped, err } = buildItemsFromParsed(fields, rows);
                    allItems = items;
                    itemsById = new Map(allItems.map(it => [it.id, it]));

                    rebuildFilterOptions(allItems);

                    visData.clear();
                    visData.add(allItems.map(it => ({
                        id: it.id,
                        start: it.start,
                        end: it.end || undefined,
                        content: it.content,
                        title: it.tooltip
                    })));

                    countLabel.textContent = String(allItems.length);
                    currentSelectedIds = [];
                    timeline.setSelection([]);
                    updateSelectedUI([]);

                    if (err) {
                        statusEl.textContent = `ERROR: ${err}`;
                    } else {
                        statusEl.textContent = `Loaded ${items.length} items. Skipped ${skipped} rows (missing/unparseable start date). Select items to populate table + map.`;
                    }

                    // Fit view
                    try { timeline.fit({ animation: false }); } catch {}
                },
                error: (err) => {
                    statusEl.textContent = "ERROR: Failed to parse CSV. Check console for details.";
                    if (window.__DBG?.enabled?.()) window.__DBG.err("PapaParse error: " + (err?.message || String(err)));
                }
            });
        }

        // ---------- Upload handling ----------
        function attachUploadHandlers() {
            dropzone.addEventListener("click", () => fileInput.click());

            fileInput.addEventListener("change", () => {
                const file = fileInput.files && fileInput.files[0];
                if (file) loadCsvFile(file);
            });

            dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("dragover"); });
            dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
            dropzone.addEventListener("drop", (e) => {
                e.preventDefault(); dropzone.classList.remove("dragover");
                const file = e.dataTransfer.files && e.dataTransfer.files[0];
                if (file) loadCsvFile(file);
            });
        }

        // ---------- Boot ----------
        document.addEventListener("DOMContentLoaded", () => {
            // Show only simple status unless debug enabled
            const libsOk = !!window.vis && !!window.Papa && !!window.L;
            if (!libsOk && window.__DBG?.enabled?.()) window.__DBG.warn(`Library check: vis=${!!window.vis}, Papa=${!!window.Papa}, Leaflet=${!!window.L}`);

            initTimeline();
            initMap();
            attachUploadHandlers();

            // Buttons
            applyBtn.addEventListener("click", applyFilters);
            resetBtn.addEventListener("click", () => { rebuildFilterOptions(allItems); resetFilters(); });

            // Debug mode wiring: show/hide overlay
            const dbgOverlay = document.getElementById("dbgOverlay");
            const debugModeSel = document.getElementById("debugMode");
            debugModeSel.addEventListener("change", () => {
                const mode = debugModeSel.value;
                if (mode === "off") dbgOverlay.style.display = "none";
                else dbgOverlay.style.display = "";
                window.__DBG.setMode(mode);
            });

            document.getElementById("status").textContent =
                "Ready. Upload a CSV. For mapping: provide either (lat,lon) or a location string (will be geocoded).";
        });

    })();
</script>
</body>
</html>