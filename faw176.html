<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Timeline + Selected Table + Map</title>

    <!-- vis-timeline -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vis-timeline@8.5.0/styles/vis-timeline-graph2d.min.css">
    <script src="https://cdn.jsdelivr.net/npm/vis-timeline@8.5.0/standalone/umd/vis-timeline-graph2d.min.js"></script>

    <!-- PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root { color-scheme: light dark; }
        body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
        header { padding: 14px 16px; border-bottom: 1px solid rgba(127,127,127,.25); }
        header h1 { margin: 0; font-size: 18px; }
        header p { margin: 6px 0 0; opacity: .8; }

        .app { display: grid; grid-template-columns: 340px 1fr; gap: 12px; padding: 12px; }
        .panel { border: 1px solid rgba(127,127,127,.25); border-radius: 10px; padding: 12px; height: fit-content; position: sticky; top: 12px; }
        .panel h2 { font-size: 14px; margin: 0 0 10px; opacity: .9; }

        .row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }
        label { font-size: 12px; opacity: .85; }
        input[type="date"], select, button {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(127,127,127,.35);
            background: transparent;
            color: inherit;
        }
        button { cursor: pointer; }
        .btnrow { display: flex; gap: 8px; flex-wrap: wrap; }

        .dropzone {
            border: 2px dashed rgba(127,127,127,.45);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
            margin-bottom: 12px;
            user-select: none;
        }
        .dropzone strong { display: block; margin-bottom: 6px; }
        .dropzone small { opacity: .8; }
        .dropzone.dragover { border-color: rgba(80,160,255,.9); }

        .status {
            border: 1px solid rgba(127,127,127,.25);
            border-radius: 10px;
            padding: 10px;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-wrap;
            max-height: 220px;
            overflow: auto;
            background: rgba(127,127,127,.06);
        }

        .main { display: grid; grid-template-rows: auto auto 360px; gap: 12px; min-width: 0; }

        .box { border: 1px solid rgba(127,127,127,.25); border-radius: 10px; overflow: hidden; background: transparent; min-width: 0; }
        #timeline { height: 420px; }

        .boxhead {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(127,127,127,.25);
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .boxhead h3 { margin: 0; font-size: 14px; }
        .boxhead .meta { font-size: 12px; opacity: .75; display:flex; gap:10px; align-items:center; flex-wrap: wrap; }

        .timeline-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        .timeline-controls button {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid rgba(127,127,127,.35);
            background: rgba(127,127,127,.08);
        }
        .timeline-controls .hint {
            font-size: 12px;
            opacity: .75;
            margin-left: 4px;
        }

        .tablewrap { overflow: auto; max-height: 320px; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th, td { padding: 8px 10px; border-bottom: 1px solid rgba(127,127,127,.2); vertical-align: top; }
        th { position: sticky; top: 0; background: rgba(127,127,127,.08); text-align: left; }
        tr:hover { background: rgba(127,127,127,.08); }
        .muted { opacity: .75; }

        #map { height: 360px; }
        .pill { display: inline-block; padding: 2px 8px; border: 1px solid rgba(127,127,127,.35); border-radius: 999px; margin-right: 6px; margin-bottom: 4px; font-size: 12px; opacity: .9; white-space: nowrap; }

        @media (max-width: 980px) {
            .app { grid-template-columns: 1fr; }
            .panel { position: static; }
            #timeline { height: 380px; }
        }
    </style>
</head>

<body>
<header>
    <h1>My Timelines 1/13/2026</h1>
    <p>Upload a CSV → timeline. Select items → table + map pins.</p>
</header>

<div class="app">
    <aside class="panel">
        <div id="dropzone" class="dropzone" tabindex="0">
            <strong>Click to upload CSV</strong>
            <small>(drag/drop also works)</small>
            <input id="fileInput" type="file" accept=".csv,text/csv" style="display:none" />
        </div>

        <h2>Status</h2>
        <div id="status" class="status">Waiting for a CSV…</div>

        <h2 style="margin-top:12px">Filters</h2>

        <div class="row">
            <label>Date range</label>
            <input id="fromDate" type="date" />
            <input id="toDate" type="date" />
        </div>

        <div class="row">
            <label>Filter by tag</label>
            <select id="tagFilter"><option value="">All tags</option></select>
        </div>

        <div class="row">
            <label>Filter by location</label>
            <select id="locFilter"><option value="">All locations</option></select>
        </div>

        <div class="btnrow">
            <button id="applyBtn" type="button">Apply</button>
            <button id="resetBtn" type="button">Reset</button>
        </div>

        <p class="muted" style="margin-top:12px;font-size:12px">
            Selection: Ctrl/Cmd+click multi-select; Shift+click range select.
        </p>
    </aside>

    <main class="main">
        <section class="box">
            <div class="boxhead">
                <h3>Timeline</h3>
                <div class="meta">
                    <span><span id="countLabel">0</span> items loaded</span>
                    <div class="timeline-controls">
                        <button id="zoomInBtn" type="button" title="Zoom in">＋</button>
                        <button id="zoomOutBtn" type="button" title="Zoom out">－</button>
                        <button id="fitBtn" type="button" title="Fit to all items">Fit</button>
                        <button id="leftBtn" type="button" title="Pan left">◀</button>
                        <button id="rightBtn" type="button" title="Pan right">▶</button>
                        <span class="hint">Mouse wheel = zoom • Shift+wheel = pan</span>
                    </div>
                </div>
            </div>
            <div id="timeline"></div>
        </section>

        <section class="box">
            <div class="boxhead">
                <h3>Selected items</h3>
                <div class="meta"><span id="selectedCount">0</span> selected</div>
            </div>
            <div class="tablewrap">
                <table>
                    <thead>
                    <tr>
                        <th style="min-width:140px">When</th>
                        <th style="min-width:180px">Title</th>
                        <th style="min-width:220px">Details</th>
                        <th style="min-width:160px">Tags</th>
                        <th style="min-width:200px">Location</th>
                        <th style="min-width:160px">Coordinates</th>
                    </tr>
                    </thead>
                    <tbody id="selectedTbody">
                    <tr><td colspan="6" class="muted">Select timeline items to populate this table.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="box">
            <div class="boxhead">
                <h3>Map</h3>
                <div class="meta">Plots selected items that have lat/lon</div>
            </div>
            <div id="map"></div>
        </section>
    </main>
</div>

<script>
    (function () {
        // ---------- Utilities ----------
        function normKey(s) { return String(s || "").trim().toLowerCase().replace(/\s+/g, "_"); }
        function escapeHtml(s) {
            return String(s ?? "")
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");
        }
        function parseTags(raw) {
            if (!raw) return [];
            return String(raw).split(/[,;|]/g).map(t => t.trim()).filter(Boolean);
        }
        function safeDate(val) {
            if (val === null || val === undefined) return null;
            const s = String(val).trim();
            if (!s) return null;

            let d = new Date(s);
            if (!isNaN(d.getTime())) return d;

            const m1 = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
            if (m1) {
                const [_, Y, M, D, hh="0", mm="0", ss="0"] = m1;
                d = new Date(Number(Y), Number(M)-1, Number(D), Number(hh), Number(mm), Number(ss));
                if (!isNaN(d.getTime())) return d;
            }

            const m2 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
            if (m2) {
                const [_, M, D, Y, hh="0", mm="0"] = m2;
                d = new Date(Number(Y), Number(M)-1, Number(D), Number(hh), Number(mm), 0);
                if (!isNaN(d.getTime())) return d;
            }
            return null;
        }
        function fmtWhen(item) {
            const s = item.start ? new Date(item.start) : null;
            const e = item.end ? new Date(item.end) : null;
            const fmt = (x) => x.toISOString().slice(0,10);
            if (s && e) return `${fmt(s)} → ${fmt(e)}`;
            if (s) return fmt(s);
            return "";
        }
        function findCol(headersNorm, candidates) {
            for (const c of candidates) {
                const want = normKey(c);
                const idx = headersNorm.indexOf(want);
                if (idx !== -1) return idx;
            }
            return -1;
        }
        function guessDateCol(fields, rows, sampleN = 50) {
            if (!fields.length) return -1;
            const N = Math.min(sampleN, rows.length);
            const scores = fields.map(() => 0);
            for (let i = 0; i < N; i++) {
                const r = rows[i];
                if (!r) continue;
                for (let c = 0; c < fields.length; c++) {
                    const v = r[fields[c]];
                    if (safeDate(v)) scores[c] += 1;
                }
            }
            let best = -1, bestScore = 0;
            for (let c = 0; c < scores.length; c++) {
                if (scores[c] > bestScore) { bestScore = scores[c]; best = c; }
            }
            return bestScore >= Math.max(3, Math.floor(N * 0.2)) ? best : -1;
        }

        function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

        // ---------- State ----------
        let allItems = [];
        let itemsById = new Map();
        let timeline = null;
        let visData = null;

        let map = null;
        let markerLayer = null;

        // ---------- DOM ----------
        const dropzone = document.getElementById("dropzone");
        const fileInput = document.getElementById("fileInput");

        const fromDate = document.getElementById("fromDate");
        const toDate = document.getElementById("toDate");
        const tagFilter = document.getElementById("tagFilter");
        const locFilter = document.getElementById("locFilter");

        const applyBtn = document.getElementById("applyBtn");
        const resetBtn = document.getElementById("resetBtn");

        const countLabel = document.getElementById("countLabel");
        const selectedCount = document.getElementById("selectedCount");
        const selectedTbody = document.getElementById("selectedTbody");

        // Timeline controls
        const zoomInBtn = document.getElementById("zoomInBtn");
        const zoomOutBtn = document.getElementById("zoomOutBtn");
        const fitBtn = document.getElementById("fitBtn");
        const leftBtn = document.getElementById("leftBtn");
        const rightBtn = document.getElementById("rightBtn");

        // ---------- Timeline ----------
        function initTimeline() {
            const container = document.getElementById("timeline");
            visData = new vis.DataSet([]);

            // Make interaction less fiddly:
            // - zoomKey: use ctrlKey to avoid accidental zoom when scrolling page
            // - zoomFriction: lower => zoom is less sensitive
            // - zoomMin/zoomMax: prevent "stuck" extremes
            // - horizontalScroll: enable horizontal scroll gestures
            // - zoomable/moveable explicitly enabled
            const options = {
                stack: true,
                multiselect: true,
                selectable: true,

                zoomable: true,
                moveable: true,
                horizontalScroll: true,
                zoomKey: "ctrlKey",
                zoomFriction: 12,

                zoomMin: 1000 * 60 * 60,                 // 1 hour minimum
                zoomMax: 1000 * 60 * 60 * 24 * 365 * 400 // 400 years max window
            };

            timeline = new vis.Timeline(container, visData, options);

            // Scroll wheel behavior improvements:
            // - Ctrl/Cmd + wheel = zoom (vis built-in via zoomKey)
            // - Shift + wheel = pan left/right (we implement)
            container.addEventListener("wheel", (e) => {
                if (!timeline) return;
                // SHIFT + wheel => horizontal pan
                if (e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    const delta = e.deltaY || e.deltaX || 0;
                    panByPixels(delta);
                }
            }, { passive: false });

            // Keyboard navigation when timeline has focus:
            // - ArrowLeft/Right: pan
            // - +/-: zoom
            // - f: fit
            container.tabIndex = 0;
            container.addEventListener("keydown", (e) => {
                if (!timeline) return;
                if (e.key === "ArrowLeft") { e.preventDefault(); panByFraction(-0.15); }
                if (e.key === "ArrowRight") { e.preventDefault(); panByFraction(0.15); }
                if (e.key === "+" || e.key === "=") { e.preventDefault(); zoomBy(0.7); }
                if (e.key === "-" || e.key === "_") { e.preventDefault(); zoomBy(1.4); }
                if (e.key.toLowerCase() === "f") { e.preventDefault(); safeFit(); }
            });

            timeline.on("select", (props) => updateSelectedUI(props.items || []));
        }

        function safeFit() {
            if (!timeline || allItems.length === 0) return;
            try { timeline.fit({ animation: { duration: 250, easingFunction: "easeInOutQuad" } }); } catch {}
        }

        // Zoom by factor: <1 zooms in, >1 zooms out
        function zoomBy(factor) {
            if (!timeline) return;
            const range = timeline.getWindow();
            const start = range.start.valueOf();
            const end = range.end.valueOf();
            const center = (start + end) / 2;
            const half = (end - start) / 2;
            const newHalf = clamp(half * factor, 1000 * 60 * 30, 1000 * 60 * 60 * 24 * 365 * 400 / 2); // 30 min to half max
            const newStart = new Date(center - newHalf);
            const newEnd = new Date(center + newHalf);
            timeline.setWindow(newStart, newEnd, { animation: { duration: 200, easingFunction: "easeInOutQuad" } });
        }

        // Pan by fraction of current window width
        function panByFraction(frac) {
            if (!timeline) return;
            const range = timeline.getWindow();
            const start = range.start.valueOf();
            const end = range.end.valueOf();
            const width = end - start;
            const shift = width * frac;
            timeline.setWindow(new Date(start + shift), new Date(end + shift), { animation: { duration: 200, easingFunction: "easeInOutQuad" } });
        }

        // Pan by pixels (rough heuristic)
        function panByPixels(px) {
            if (!timeline) return;
            const range = timeline.getWindow();
            const start = range.start.valueOf();
            const end = range.end.valueOf();
            const width = end - start;

            const container = document.getElementById("timeline");
            const wpx = Math.max(300, container.clientWidth || 800);
            const frac = px / wpx; // 1 container width ~ full window width
            const shift = width * frac;

            timeline.setWindow(new Date(start + shift), new Date(end + shift), { animation: false });
        }

        function wireTimelineControls() {
            zoomInBtn.addEventListener("click", () => zoomBy(0.7));
            zoomOutBtn.addEventListener("click", () => zoomBy(1.4));
            fitBtn.addEventListener("click", () => safeFit());
            leftBtn.addEventListener("click", () => panByFraction(-0.25));
            rightBtn.addEventListener("click", () => panByFraction(0.25));
        }

        // ---------- Map ----------
        function initMap() {
            map = L.map("map", { zoomControl: true });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: "&copy; OpenStreetMap contributors"
            }).addTo(map);

            markerLayer = L.layerGroup().addTo(map);
            map.setView([20, 0], 2);
        }

        // ---------- Selection -> Table + Map ----------
        function updateSelectedUI(selectedIds) {
            selectedCount.textContent = String(selectedIds.length);

            selectedTbody.innerHTML = "";
            if (selectedIds.length === 0) {
                selectedTbody.innerHTML = `<tr><td colspan="6" class="muted">Select timeline items to populate this table.</td></tr>`;
                markerLayer.clearLayers();
                return;
            }

            for (const id of selectedIds) {
                const it = itemsById.get(id);
                if (!it) continue;

                const tagsHtml = (it.tags || []).length
                    ? it.tags.map(t => `<span class="pill">${escapeHtml(t)}</span>`).join("")
                    : `<span class="muted">—</span>`;

                const loc = it.location ? escapeHtml(it.location) : `<span class="muted">—</span>`;
                const coords = (isFinite(it.lat) && isFinite(it.lon))
                    ? `${Number(it.lat).toFixed(5)}, ${Number(it.lon).toFixed(5)}`
                    : `<span class="muted">—</span>`;

                const details = it.details ? escapeHtml(it.details) : `<span class="muted">—</span>`;

                const tr = document.createElement("tr");
                tr.innerHTML = `
        <td>${escapeHtml(fmtWhen(it))}</td>
        <td>${escapeHtml(it.title || "")}</td>
        <td>${details}</td>
        <td>${tagsHtml}</td>
        <td>${loc}</td>
        <td>${coords}</td>
      `;
                selectedTbody.appendChild(tr);
            }

            // Map markers
            markerLayer.clearLayers();
            const bounds = [];
            for (const id of selectedIds) {
                const it = itemsById.get(id);
                if (!it) continue;
                if (isFinite(it.lat) && isFinite(it.lon)) {
                    const title = escapeHtml(it.title || "Item");
                    const loc = escapeHtml(it.location || "");
                    const when = escapeHtml(fmtWhen(it));
                    const m = L.marker([it.lat, it.lon])
                        .bindPopup(`<strong>${title}</strong><br>${loc}<br><span class="muted">${when}</span>`);
                    markerLayer.addLayer(m);
                    bounds.push([it.lat, it.lon]);
                }
            }
            if (bounds.length === 1) map.setView(bounds[0], 10);
            if (bounds.length > 1) map.fitBounds(bounds, { padding: [20, 20] });
        }

        // ---------- Filtering ----------
        function rebuildFilterOptions(items) {
            const tags = new Set();
            const locs = new Set();
            for (const it of items) {
                (it.tags || []).forEach(t => tags.add(t));
                if (it.location) locs.add(it.location);
            }

            const curTag = tagFilter.value;
            const curLoc = locFilter.value;

            tagFilter.innerHTML = `<option value="">All tags</option>` +
                Array.from(tags).sort((a,b)=>a.localeCompare(b)).map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join("");

            locFilter.innerHTML = `<option value="">All locations</option>` +
                Array.from(locs).sort((a,b)=>a.localeCompare(b)).map(l => `<option value="${escapeHtml(l)}">${escapeHtml(l)}</option>`).join("");

            tagFilter.value = Array.from(tags).includes(curTag) ? curTag : "";
            locFilter.value = Array.from(locs).includes(curLoc) ? curLoc : "";
        }

        function applyFilters() {
            const fd = fromDate.value ? safeDate(fromDate.value) : null;
            const td = toDate.value ? safeDate(toDate.value) : null;
            const tag = tagFilter.value || "";
            const loc = locFilter.value || "";

            const filtered = allItems.filter(it => {
                const s = it.start ? new Date(it.start) : null;
                const e = it.end ? new Date(it.end) : null;
                const anchor = s || e;
                if (fd && anchor && anchor < fd) return false;
                if (td && anchor && anchor > td) return false;
                if (tag && !(it.tags || []).includes(tag)) return false;
                if (loc && (it.location || "") !== loc) return false;
                return true;
            });

            visData.clear();
            visData.add(filtered.map(it => ({
                id: it.id,
                start: it.start,
                end: it.end || undefined,
                content: it.content,
                title: it.tooltip
            })));

            countLabel.textContent = String(filtered.length);

            timeline.setSelection([]);
            updateSelectedUI([]);

            document.getElementById("status").textContent =
                `Applied filters. Showing ${filtered.length} / ${allItems.length} items.`;

            // Helpful after filtering: fit to visible items
            try { timeline.fit({ animation: { duration: 200, easingFunction: "easeInOutQuad" } }); } catch {}
        }

        function resetFilters() {
            fromDate.value = "";
            toDate.value = "";
            tagFilter.value = "";
            locFilter.value = "";

            visData.clear();
            visData.add(allItems.map(it => ({
                id: it.id,
                start: it.start,
                end: it.end || undefined,
                content: it.content,
                title: it.tooltip
            })));

            countLabel.textContent = String(allItems.length);

            timeline.setSelection([]);
            updateSelectedUI([]);

            document.getElementById("status").textContent = `Reset filters. Showing all ${allItems.length} items.`;

            safeFit();
        }

        // ---------- CSV -> items ----------
        function buildItemsFromParsed(fields, rows) {
            const headersNorm = fields.map(normKey);

            let idxStart = findCol(headersNorm, ["start", "date", "when", "begin", "timestamp", "time"]);
            const idxEnd = findCol(headersNorm, ["end", "finish", "stop", "until"]);
            const idxTitle = findCol(headersNorm, ["title", "name", "event", "summary"]);
            const idxDetails = findCol(headersNorm, ["details", "description", "content", "notes", "text", "body"]);
            const idxTags = findCol(headersNorm, ["tags", "tag", "labels", "label"]);
            const idxLoc = findCol(headersNorm, ["location", "place", "where", "city"]);
            const idxLat = findCol(headersNorm, ["lat", "latitude"]);
            const idxLon = findCol(headersNorm, ["lon", "lng", "longitude", "long"]);

            if (idxStart === -1) idxStart = guessDateCol(fields, rows);
            if (idxStart === -1) return { items: [], skipped: rows.length, err: "Could not find a date/start column." };

            const now = Date.now();
            const items = [];
            let skipped = 0;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                if (!row || Object.keys(row).length === 0) { skipped++; continue; }

                const startVal = row[fields[idxStart]];
                const endVal = (idxEnd >= 0) ? row[fields[idxEnd]] : null;

                const start = safeDate(startVal);
                const end = safeDate(endVal);
                if (!start) { skipped++; continue; }

                const title = (idxTitle >= 0 ? String(row[fields[idxTitle]] || "").trim() : "") || "Item";
                const details = idxDetails >= 0 ? String(row[fields[idxDetails]] || "").trim() : "";
                const tags = idxTags >= 0 ? parseTags(row[fields[idxTags]]) : [];
                const location = idxLoc >= 0 ? String(row[fields[idxLoc]] || "").trim() : "";

                const lat = idxLat >= 0 ? Number(row[fields[idxLat]]) : NaN;
                const lon = idxLon >= 0 ? Number(row[fields[idxLon]]) : NaN;

                const id = `${now}-${i}`;
                const content = `<div><strong>${escapeHtml(title)}</strong><div class="muted" style="font-size:12px">${escapeHtml(location || "")}</div></div>`;

                const tooltipParts = [];
                tooltipParts.push(title);
                tooltipParts.push(fmtWhen({ start, end }));
                if (location) tooltipParts.push(location);
                if (tags.length) tooltipParts.push(`Tags: ${tags.join(", ")}`);
                if (details) tooltipParts.push(details);

                items.push({
                    id,
                    start,
                    end,
                    title,
                    details,
                    tags,
                    location,
                    lat,
                    lon,
                    content,
                    tooltip: tooltipParts.filter(Boolean).join("\n")
                });
            }

            return { items, skipped, err: null };
        }

        function loadCsvFile(file) {
            const statusEl = document.getElementById("status");
            statusEl.textContent = `Reading: ${file.name} (${file.size} bytes)…`;

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                complete: (results) => {
                    const fields = (results.meta && results.meta.fields) ? results.meta.fields : [];
                    const rows = results.data || [];

                    if (!fields.length) {
                        statusEl.textContent = "ERROR: No headers detected. Ensure the first row is a header row.";
                        return;
                    }

                    const { items, skipped, err } = buildItemsFromParsed(fields, rows);
                    allItems = items;
                    itemsById = new Map(allItems.map(it => [it.id, it]));

                    rebuildFilterOptions(allItems);

                    visData.clear();
                    visData.add(allItems.map(it => ({
                        id: it.id,
                        start: it.start,
                        end: it.end || undefined,
                        content: it.content,
                        title: it.tooltip
                    })));

                    countLabel.textContent = String(allItems.length);
                    timeline.setSelection([]);
                    updateSelectedUI([]);

                    if (err) {
                        statusEl.textContent = `ERROR: ${err}`;
                    } else {
                        statusEl.textContent = `Loaded ${items.length} items. Skipped ${skipped} rows (missing/unparseable start date).`;
                    }

                    // Fit to data after load
                    safeFit();
                },
                error: (err) => {
                    statusEl.textContent = "ERROR: Failed to parse CSV. Check console for details.";
                    console.error(err);
                }
            });
        }

        // ---------- Upload handling ----------
        function attachUploadHandlers() {
            dropzone.addEventListener("click", () => fileInput.click());

            fileInput.addEventListener("change", () => {
                const file = fileInput.files && fileInput.files[0];
                if (file) loadCsvFile(file);
            });

            dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("dragover"); });
            dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
            dropzone.addEventListener("drop", (e) => {
                e.preventDefault(); dropzone.classList.remove("dragover");
                const file = e.dataTransfer.files && e.dataTransfer.files[0];
                if (file) loadCsvFile(file);
            });
        }

        // ---------- Boot ----------
        document.addEventListener("DOMContentLoaded", () => {
            initTimeline();
            initMap();
            attachUploadHandlers();
            wireTimelineControls();

            applyBtn.addEventListener("click", applyFilters);
            resetBtn.addEventListener("click", () => { rebuildFilterOptions(allItems); resetFilters(); });

            document.getElementById("status").textContent =
                "Ready. Upload a CSV. Timeline tips: Ctrl/Cmd+wheel to zoom, Shift+wheel to pan, or use buttons.";
        });
    })();
</script>
</body>
</html>