<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>7-Day Weather Tables • Drag-and-Drop Locations</title>
    <meta name="description" content="Generate 7-day weather tables from Open-Meteo by dragging in a text file of locations or pasting a list." />
    <style>
        :root {
            --bg: #0b1020; --panel:#11172b; --muted:#97a0b3; --text:#e8ecf3; --accent:#6ea8fe; --err:#ff6b6b; --shadow: 0 10px 24px rgba(0,0,0,.35);
        }
        html, body { height: 100%; }
        body {
            margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            color:var(--text);
            background: radial-gradient(1250px 800px at 20% -10%, #1a2340, #0b1020 60%);
        }
        .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
        header { display:grid; gap:8px; margin-bottom:16px; }
        h1 { margin:0; font-size: clamp(22px, 2.8vw, 32px); }
        .sub { color: var(--muted); }
        .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

        .panel { background: linear-gradient(180deg, #101833 0%, #0f152b 100%); border:1px solid #1c2a4d; border-radius:16px; box-shadow: var(--shadow); padding:18px; }
        .controls { display:grid; gap:12px; }
        .row { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
        @media (max-width: 640px){ .row{ grid-template-columns: 1fr; } }
        label { font-weight:600; font-size:14px; }
        input[type="text"], input[type="file"] { width:100%; box-sizing:border-box; padding:10px 12px; border-radius:10px; border:1px solid #2a3a6a; background:#0b142c; color:var(--text); }
        .btn { appearance:none; border:1px solid #2a3a6a; color:var(--text); background:#0b142c; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; }
        .btn:hover { background:#12214a; border-color:#3b57a3; }

        .dropzone { border:2px dashed #2a3a6a; border-radius:16px; padding:22px; text-align:center; color:var(--muted); }
        .dropzone.dragover { background: rgba(64,105,215,0.12); border-color: var(--accent); color: var(--text); }

        .grid { display:grid; grid-template-columns: 1fr; gap:16px; margin-top:18px; }
        .card { background: var(--panel); border:1px solid #1b2647; border-radius:16px; padding:12px; box-shadow: var(--shadow); }
        .card h3 { margin:6px 8px 0; font-size:16px; font-weight:700; }
        .meta { color: var(--muted); font-size:12px; margin: 0 8px 6px; }
        .bad { color: var(--err); }

        table.wx { width:100%; border-collapse: collapse; }
        table.wx th, table.wx td { border-bottom:1px solid #25345f; padding:8px 10px; text-align:left; }
        table.wx thead th { position: sticky; top: 0; background:#121a33; z-index:1; }
        table.wx tbody tr:hover { background: rgba(64,105,215,0.08); }
    </style>

    <script type="module" defer>
        // --- Endpoints ---
        const GEOCODE = "https://geocoding-api.open-meteo.com/v1/search";
        const FORECAST = "https://api.open-meteo.com/v1/forecast";

        // --- Minimal WMO -> text mapping ---
        const WMO = new Map(Object.entries({
            0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",
            45:"Fog",48:"Rime fog",
            51:"Drizzle light",53:"Drizzle mod",55:"Drizzle heavy",
            61:"Rain light",63:"Rain mod",65:"Rain heavy",
            71:"Snow light",73:"Snow mod",75:"Snow heavy",
            80:"Rain showers",81:"Rain shw mod",82:"Rain shw heavy",
            95:"Thunderstorm",96:"Tstorm hail",99:"Tstorm heavy hail"
        }));

        // --- DOM helpers ---
        function el(tag, attrs={}, children=[]) {
            const e = document.createElement(tag);
            for (const [k,v] of Object.entries(attrs)) {
                if (k === 'class') e.className = v;
                else if (k === 'text') e.textContent = v;
                else e.setAttribute(k, v);
            }
            for (const c of (Array.isArray(children)?children:[children])) if(c) e.append(c);
            return e;
        }

        // Parse one line: "City, State" or "lat,lon" or "lat,lon,desc"
        function parseLine(line){
            const raw = line.split('#')[0].trim();
            if(!raw) return null;
            const m = raw.match(/^\s*([+-]?\d+(?:\.\d+)?)\s*,\s*([+-]?\d+(?:\.\d+)?)\s*(?:,(.*))?\s*$/);
            if(m){
                const lat = Number(m[1]), lon = Number(m[2]);
                if(Number.isFinite(lat) && Number.isFinite(lon) && lat>=-90 && lat<=90 && lon>=-180 && lon<=180){
                    const desc = (m[3]||'').trim();
                    return { type:'coords', lat, lon, label: desc || `${lat.toFixed(3)},${lon.toFixed(3)}` };
                }
            }
            return { type:'place', q: raw };
        }

        // Prefer US/NJ if ambiguous; adjust as needed
        async function geocode(q, prefs={admin1:'New Jersey', country:'United States'}){
            const params = new URLSearchParams({ name:q, count:'5', language:'en' });
            const r = await fetch(`${GEOCODE}?${params}`);
            if(!r.ok) throw new Error(`Geocoding failed ${r.status}`);
            const data = await r.json();
            const results = data.results || [];
            if(results.length===0) throw new Error(`No match for "${q}"`);

            const scored = results.map((r)=>{
                let s=0;
                if(prefs.country && r.country===prefs.country) s+=2;
                if(prefs.admin1 && r.admin1 && r.admin1.toLowerCase().includes(prefs.admin1.toLowerCase())) s+=1;
                return {r, s, pop:r.population||0};
            }).sort((a,b)=> (b.s-a.s) || (b.pop-a.pop));

            const best = scored[0].r;
            const label = [best.name, best.admin1, best.country].filter(Boolean).join(', ');
            return { lat: best.latitude, lon: best.longitude, label };
        }

        async function fetchDaily(lat, lon, days=7){
            const params = new URLSearchParams({
                latitude:String(lat), longitude:String(lon),
                timezone:'auto', temperature_unit:'fahrenheit', precipitation_unit:'inch',
                forecast_days:String(days),
                // IMPORTANT: do not include "time" here; API returns daily.time automatically
                daily: [
                    "temperature_2m_max",
                    "temperature_2m_min",
                    "precipitation_sum",
                    "uv_index_max",
                    "wind_gusts_10m_max",
                    "weather_code"
                ].join(',')
            });
            const r = await fetch(`${FORECAST}?${params}`);
            if(!r.ok){
                const txt = await r.text();
                throw new Error(`Forecast failed ${r.status}: ${txt}`);
            }
            const data = await r.json();
            if(data.error){ throw new Error(data.reason || 'API error'); }
            return data.daily;
        }

        function buildTable(daily){
            const tbl = el('table', { class:'wx' });
            const thead = el('thead');
            thead.append(el('tr', {}, [
                el('th', { text:'Date' }),
                el('th', { text:'High (°F)' }),
                el('th', { text:'Low (°F)' }),
                el('th', { text:'Precip (in)' }),
                el('th', { text:'UV' }),
                el('th', { text:'Gust (mph)' }),
                el('th', { text:'Conditions' })
            ]));
            const tbody = el('tbody');
            const n = daily.time.length;
            for(let i=0;i<n;i++){
                const dt = new Date(daily.time[i]);
                const dateStr = dt.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' });
                const hi = daily.temperature_2m_max?.[i];
                const lo = daily.temperature_2m_min?.[i];
                const p  = daily.precipitation_sum?.[i];
                const uv = daily.uv_index_max?.[i];
                const g  = daily.wind_gusts_10m_max?.[i];
                const code = daily.weather_code?.[i];
                const cond = (code==null) ? '—' : (WMO.get(String(code)) || WMO.get(code) || String(code));
                tbody.append(el('tr', {}, [
                    el('td', { text: dateStr }),
                    el('td', { text: Number.isFinite(hi)? hi.toFixed(0) : '–' }),
                    el('td', { text: Number.isFinite(lo)? lo.toFixed(0) : '–' }),
                    el('td', { text: Number.isFinite(p)? p.toFixed(2) : '–' }),
                    el('td', { text: Number.isFinite(uv)? uv.toFixed(0) : '–' }),
                    el('td', { text: Number.isFinite(g)? g.toFixed(0) : '–' }),
                    el('td', { text: cond })
                ]));
            }
            tbl.append(thead, tbody);
            return tbl;
        }

        async function buildCard(target, item){
            const card = el('section', { class:'card', role:'region' });
            const h = el('h3', { text:'Loading…' });
            const meta = el('p', { class:'meta', text:'Resolving location…' });
            card.append(h, meta);
            target.prepend(card);

            try {
                const coords = (item.type==='coords')
                    ? {lat:item.lat, lon:item.lon, label:item.label}
                    : await geocode(item.q);

                h.textContent = coords.label;
                meta.textContent = 'Fetching 7-day forecast…';
                const daily = await fetchDaily(coords.lat, coords.lon, 7);

                // handy summary (max UV / gust) above the table
                const maxUV = Math.max(...(daily.uv_index_max||[0]));
                const maxG = Math.max(...(daily.wind_gusts_10m_max||[0]));
                meta.textContent = `UV max: ${Number.isFinite(maxUV)? maxUV.toFixed(0): '–'} • Gust max: ${Number.isFinite(maxG)? maxG.toFixed(0): '–'} mph`;

                card.append(buildTable(daily));
            } catch(err){
                h.textContent = 'Failed to load';
                meta.textContent = String(err.message||err);
                meta.classList.add('bad');
            }
        }

        function parseAll(text){
            const lines = text.split(/\r?\n/);
            const items = [];
            for(const ln of lines){
                const p = parseLine(ln);
                if(p) items.push(p);
            }
            if(items.length===0) throw new Error('No valid locations found.');
            return items;
        }

        // --- UI wiring ---
        const dz = document.getElementById('drop');
        const fileInput = document.getElementById('file');
        const pasteArea = document.getElementById('paste');
        const runBtn = document.getElementById('run');
        const grid = document.getElementById('grid');

        function clearGrid(){ grid.innerHTML=''; }

        async function processText(text){
            clearGrid();
            const items = parseAll(text).slice(0, 24); // reasonable cap
            for(const it of items){ await buildCard(grid, it); }
        }

        dz.addEventListener('dragover', (e)=>{ e.preventDefault(); dz.classList.add('dragover'); });
        dz.addEventListener('dragleave', ()=> dz.classList.remove('dragover'));
        dz.addEventListener('drop', async (e)=>{
            e.preventDefault(); dz.classList.remove('dragover');
            const f = e.dataTransfer.files?.[0]; if(!f) return;
            const text = await f.text(); await processText(text);
        });

        fileInput.addEventListener('change', async (e)=>{
            const f = e.target.files?.[0]; if(!f) return;
            const text = await f.text(); await processText(text); fileInput.value='';
        });

        runBtn.addEventListener('click', async ()=>{
            const text = pasteArea.value.trim();
            if(!text){ alert('Paste locations first, or drop a file.'); return; }
            await processText(text);
        });
    </script>
</head>
<body>
<div class="wrap">
    <header>
        <h1>7-Day Weather Tables</h1>
        <p class="sub">Drag-and-drop a text file of locations (or paste below) to generate tables. Formats: <code>City, State</code>, <code>lat,lon</code>, or <code>lat,lon,desc</code>.</p>
    </header>

    <section class="panel controls" aria-labelledby="ctl">
        <h2 id="ctl" class="sr-only">Controls</h2>
        <div id="drop" class="dropzone" tabindex="0" aria-label="Drop a locations file here">
            <strong>Drop file here</strong>
            <div class="sub">One location per line. Lines starting with <code>#</code> are ignored.</div>
        </div>
        <div class="row">
            <div>
                <label for="file">Or pick a file</label>
                <input id="file" type="file" accept=".txt,.csv,text/plain" />
            </div>
            <div>
                <label for="paste">Or paste a list</label>
                <input id="paste" type="text" placeholder="e.g., Piscataway, New Jersey | 40.728,-73.995,Greenwich Village" />
            </div>
        </div>
        <div>
            <button id="run" class="btn" type="button">Generate Tables</button>
        </div>
    </section>

    <section class="grid" id="grid" aria-live="polite" aria-busy="false"></section>
</div>
</body>
</html>